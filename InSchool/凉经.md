[TOC]

# 要点

decltype 类型指示符

void (*pf) (int &) 函数指针

void f() const {} 常量成员函数，将this转换为指向常量的this

构造函数不能被声明成const，直到构造函数完成初始化过程，对象才能取得“常量”属性

默认生成的类成员函数：构造，拷贝，赋值，析构

可变类数据类型 mutable，属于类全局变量

可基于const重载，即对常量成员函数进行重载

类声明过，就允许包含它自身类型的引用或指针

static关键字只出现在类内部的声明语句

IO操作通常以引用方式传递和返回流，不能为const

rtti机制

构造函数不能声明为虚函数的原因

工厂模式

 lambda表达式，变量截取为 & 时，注意 & 的变量的声明周期，若为指针则注意是否为悬空指针

句柄

内存映射



## 自己整理的

### 指针与引用

#### 为什么使用指针

* 指针能有效表示数据结构
* 能动态分配内存，实现内存的自由管理
* 能方便地使用字符串
* 指针直接与数据的存储地址有关（值传递不如地址传递高效）

#### 指针与引用的区别

本质上指针是地址，引用是别名

具体

* 在运行时，指针能改变所指向的值，而引用与对象绑定后就不再改变
* 内存分配上，程序为指针分配内存而不为引用分配。引用不能为空
* 编译时，指针和引用都被添加到符号表上，符号表记录的是变量名和变量所对应的地址。指针对应的地址值为**指针变量的地址值**，而引用的地址为**引用对象的地址值**
* 指针的指针是合法的，引用的引用是非法的

#### 智能指针

介绍：主要用于管理堆上的内存。它将普通指针封装为一个栈对象，当栈对象的生存周期结束后，记载析构函数中释放申请的内存。share_ptr采用引用计数的方式记录当前资源被多少智能指针引用，只有当引用计数为0时，智能指针才会释放引用的内存资源。对智能指针初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数，构造函数传入普通指针，通过get函数获得普通指针。

##### 为什么要使用智能指针

智能指针能在生命周期结束的时候自动释放内存空间，不用手动释放，避免了一般指针忘记释放空间造成内存泄漏的问题

##### shared_ptr

默认初始化的智能指针保存着一个空指针

```c++
shared_ptr<string> p1 = make_shared<string>("hello");//分配空间
```

可以认为每个shared_ptr都有一个关联的计数器，通常称为引用计数，当shared_ptr不再指向原来的对象时，计数器会递减，当一个shared_ptr的计数器变为0时，它会自动释放所管理的对象。

当动态对象不再被使用时，shared_ptr类还会自动释放动态对象。

```c++
#include <new>
int *p = new (nothrow)int;//内存分配失败不报错，返回空指针
```

new和shared_ptr结合使用

```c++
shared_pre<int> p(new int(1024))//接受指针参数的智能指针为explicit，必须使用直接初始化
```

改变shared_ptr的指向

```c++
p.reset();//释放p
p.reset(q);//令p指向q
```

不要混用普通指针和智能指针

p和q是相互独立创建的，指向同一块内存的指针，各自的引用计数都是1，所以当q的程序块结束时，q被销毁，q所指向的内存被释放，p就变成一个空悬指针

```c++
shared_ptr<int> p(new int(10));
int *q = p.get();
{
    //报错
    shared_ptr(q);//两个独立的shared_ptr指向同一个内存
}//程序块结束，q被销毁，所指向的内存被释放
int foo = *p;//未定义，p所指向的内存被释放
```

利用reset重置引用次数

```c++
shared_ptr<int> p(new int(10));
shared_ptr<int> q = p;
cout << p.use_count() << endl;
p.reset(new int (10));
cout << p.use_count() << endl;
```

shared_ptr在销毁的时候会检测引用计数，当发生异常时，直接管理的内存是不会自动释放的。

智能指针规范

> 不使用相同的内置指针值初始化（或reset）多个智能指针
>
> 不delete get()返回的指针
>
> 不使用get()初始化或reset另一个智能指针
>
> 如果使用get()返回的指针，记住当最后一个对应的智能指针销毁后，指针就变无效了
>
> 如果使用智能指针管理的资源不是new分配的内存，记得给它一个删除器



##### unique_ptr

保证同一时间只有一个unique_ptr指向该对象，因此unique_ptr不支持普通的拷贝和

赋值操作

通过release或reset将指针所有权转移

```c++
unique_ptr<string> p1(new string("Hello"));
unique_ptr<string> p2(p1.release());
```

release返回unique_ptr当前保存的指针并将其置空

例外：可以拷贝和赋值一个将销毁的unique_ptr，从函数返回一个unique_ptr

```c++
unique_ptr<int> clone(int p) {
    return unique_ptr<int>(new int(p));
}
```

##### weak_ptr

不控制所指向对象生存期的智能指针，指向一个由shared_ptr管理的对象，将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象也会被释放。

由于对象可能不存在，所以需要调用lock，若对象存在，返回一个只想共享对象的sahred_ptr，若对象不存在，lock将返回一个空指针。

### c/c++内存管理

#### 内存分配方式

* 栈：由编译器自动分配释放，分配容量有限
* 堆：由程序员分配释放，若程序员不释放，程序结束时由OS回收
* 全局区（静态区）：初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块变量
* 代码段（常量区）：程序的核心数据

函数体内定义的变量通常在栈上，malloc等分配内存的函数分配在堆上，全局变量和static都在全局区

#### **栈与堆的区别**

> **堆是共有的空间，分为全局堆和局部堆；栈是线程独有的，保存其运行状态和局部自动变量的**
>
> 管理方式：**栈是机器系统提供的数据结构；堆是c/c++函数库提供的，容易产生内存溢出**
>
> 空间大小：windows下栈的默认空间为2M（可修改），堆内存可达到8G（64位）
>
> 碎片问题：对于堆，频繁的new/delete会造成内存空间的不连续，产生大量碎片，而栈是先进后出的，不会有这个问题
>
> 生长方向：堆是从低地址到高地址生长，栈是从高地址到低地址生长的
>
> 分配效率：计算机底层有对栈的支持，分配专门的寄存器存放栈的地址，效率较高。堆的效率较低，但是能分配大量的空间。

栈溢出解决方法

* 修改算法错误（减少递归次数、减少空间、指针越界）
* 手动设置系统栈大小
* 使用堆变量

#### new和malloc的区别

* 属性：new/delete是c++的关键字需要编译器支持。malloc/free是库函数，需要头文件支持。
* 参数：使用new操作符无须指定内存块的大小，malloc则需要显式指出所需内存的尺寸。
* 返回类型：new返回的是对象类型的指针，malloc分配成功则返回void *，需要强制类型转换
* 分配失败：new分配失败会抛出bac_alloc异常，malloc分配内存失败时返回NULL
* new会调用operator new函数，申请足够的内存（通常底层为malloc实现），然后调用类型的构造函数，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）；malloc/free时库函数，智能动态的申请和释放内存，无法强制要求对象进行构造和析构。
* 重载：c++允许重载new/delete操作符，malloc不允许重载

### c++类static成员初始化

类的静态成员变量的初始化必须在类外实现

```c++
class A {
    public: static int a;
}
int A::a = 1;
```

### 嵌套类和局部类

嵌套类

> 将类声明放在另一个类中，在另一个类中声明的类被称为嵌套类，它通过提供新的类型类作用域来避免名称混乱。



```c++
class A {
public:
    A(){
        cout << " A " << endl;
    }

    class B {
    public:
        B() {
            cout << " B " << endl;
        }
    };
};

int main() {
    A a;
    A::B b;
    return 0;
}
```

### 线程间的通信

方式：共享内存、消息传递

```c++
int sum = 0;
void *thread_summation(void *arg) {
    cout << "pthread start" << endl;
    int start = ((int *)arg)[0];
    int end = ((int *)arg)[1];
    while(start <= end) {
        sum += start;
        start++;
    }
    cout << sum << " pthread end "  << endl;
    return NULL;
}

int main() {
    pthread_t id1, id2;
    int range1[] = {1, 5}, range2[] = {6, 10};
    pthread_create(&id1, nullptr, thread_summation, (void *)range1);//创建线程
    pthread_create(&id2, nullptr, thread_summation, (void *)range2);
    pthread_join(id1, NULL);//运行线程
    pthread_join(id2, NULL);
    return 0;
}
```

### 线程中的几种锁

#### 互斥锁

互斥锁用于控制多个线程堆他们之间共享资源互斥访问的一个信号量。

```c++
    pthread_mutex_t pt;//互斥锁
    pthread_mutex_init(&pt, nullptr);//动态方式创建锁
    pthread_mutex_destroy(&pt);//释放互斥锁
    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//静态方式创建锁
    pthread_mutex_lock(&pt);//以阻塞方式运行
    pthread_mutex_unlock(&pt);
    pthread_mutex_trylock(&pt);//尝试对pt加锁，如果pt之前被锁定返回非0，否则返回0并锁定tp
    //该函数为非阻塞方式，若pt之前已经被锁定，返回非0，程序会继续执行
```

#### 条件锁

条件锁就是所谓的条件变量。当条件变量满足某个条件时，某个线程可改变为阻塞状态，同样当条件满足时也能以“信号量”的方式唤醒一个因该条件被阻塞的线程。

```c++
    pthread_mutex_t mutex;
    pthread_cond_t pt;
    pthread_cond_init(&pt, nullptr);//动态创建条件变量
    pthread_cond_destroy(&pt);//释放
    pthread_cond_t condition  = PTHREAD_COND_INITIALIZER;//静态创建条件变量
    pthread_cond_wait(&pt, &mutex);//以阻塞方式执行
    //首先解锁互斥锁，然后以阻塞方式等待条件变量的信号，收到信号后又会对互斥锁加锁
    //为了方式虚假唤醒，该函数一般放在while循环体中
    {
        pthread_mutex_lock(&mutex);//加互斥锁
        while("条件不成立") {
            pthread_cond_wait(&pt, &mutex);
        }
        //对进程间的共享资源进行操作
        pthread_mutex_unlock(&mutex);//释放互斥锁
    }
    pthread_cond_signal(&pt);//唤醒一个等待中的线程
    pthread_cond_broadcast(&pt)//以广播方式唤醒因为该条件变量而阻塞的线程
    timespec time;
    pthread_cond_timedwait(&pt, &mutex, &time);//以阻塞方式等待，如果时间time到了条件还没有满足还是会结束
```

#### 自旋锁

跟互斥锁类似，但是自旋锁会让cpu一直处于忙等状态

#### 读写锁



## 宏定义

https://blog.csdn.net/imgosty/article/details/81901183

## __declspec(dllimport) 用法

https://blog.csdn.net/bzhxuexi/article/details/38420115



## QT添加外部库

先把头文件和lib库放在项目文件夹下，然后把dll文件放在bulid - debug文件夹下，然后项目右键，添加库(即自动在pro文件中添加链接)，之后先编译qmake，然后再构建项目



## 字节跳动提问

### c++如何防止头文件重复调用

* 使用宏定义避免重复引入

  ```C++
  //_NAME_H为宏名称（唯一）
  #ifndef _NAME_H
  #define _NAME_H
  //头文件内容
  #endif
  ```

* 使用#pragma once避免重复引入

  效率比宏定义快，但是较老的编译器不支持该指令

  ```c++
  #pragma once
  class classname {};
  ```

* 使用_Pragma操作符

  跟#pragma once类似，不仅可以实现#pragma once的所有功能，还能搭配宏使用

  ```c++
  //在文件开头添加
  _Pragma("once")
  ```

  

### c++如何查找第三方库的位置

通过系统的环境变量查到找第三方库所在的路径，再通过库中的cmake配置文件设置include的路径变量，LIB路径，还有lib列表

### map和Hashmap的区别

map内部为红黑树，数据有序

hashmap由数组+链表组成，将key值哈希后存储，数据无序

> hashmap的主体为数组，链表是为了解决哈希冲突（链地址法），节点 > 8 时转为红黑树， < 6时又转回链表 

### 进程间通信(管道、消息队列、信号量、信号、共享内存、套接字)

* 无名管道：半双工，数据只能单向流动，只能在具有亲缘关系的进程间使用（通常指父子进程关系）
* 高级管道：将另一个进程当作一个新的进程在当前程序进程中启动
* 有名管道：半双工，允许无亲缘关系进程间通信
* 消息队列：链表结构
* 信号量：主要作为进程间及同一进程下不同线程间的同步手段
* 信号：用于通知接收进程某一事件已经发生
* 共享内存：最快的IPC方式，通常与其他通信机制配合使用
* 套接字（socket）：可用于不同机器间的进程通信

### STL的vector的容量是如何变化的

vector的容量不够时，容量会扩充为原来的2倍，原数组中的数据copy过去

### 堆和栈的存放位置及栈溢出解决方法

> 在操作系统中，栈在寄存器上（SP寄存器）

c中的存储区

* 栈：由编译器自动分配释放
* 堆：由程序员分配释放，若程序员不释放，程序结束时由OS回收
* 全局区（静态区）：初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块变量
* 代码段（常量区）：程序的核心数据

函数体内定义的变量通常在栈上，malloc等分配内存的函数分配在堆上，全局变量和static都在全局区

> **堆是共有的空间，分为全局堆和局部堆；栈是线程独有的，保存其运行状态和局部自动变量的**
>
> 管理方式：**栈是机器系统提供的数据结构；堆是c/c++函数库提供的，容易产生内存溢出**
>
> 空间大小：windows下栈的默认空间为2M（可修改），堆内存可达到8G（64位）
>
> 碎片问题：对于堆，频繁的new/delete会造成内存空间的不连续，产生大量碎片，而栈是先进后出的，不会有这个问题
>
> 生长方向：堆是从低地址到高地址生长，栈是从高地址到低地址生长的
>
> 分配效率：计算机底层有对栈的支持，分配专门的寄存器存放栈的地址，效率较高。堆的效率较低，但是能分配大量的空间。

栈溢出解决方法

* 修改算法错误（减少递归次数、减少空间、指针越界）
* 手动设置系统栈大小
* 使用堆变量

### 源文件转换为可执行文件

1. 预处理（preprocessor）：对#include、#define等进行处理
2. 编译（compiler）：将源码编译为汇编代码
3. 汇编（assembler）：将汇编代码汇编为目标代码
4. 链接（linker）：将目标代码链接为可执行文件

### 数据库中char和varchar的区别

char是定长字符型数据，varchar为可变长字符型数据

char的空间效率比varchar低

char的时间效率比varchar高

char会自动填充空格

### 数据库命令的执行流程

<img src="https://img2020.cnblogs.com/blog/1468231/202007/1468231-20200730192944328-818716181.png" style="zoom:30%;" />

* 客户端发送一条查询给服务器
* 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果，否则进入下一阶段
* 服务器段进行SQL解析、预处理，在优化器生成对应的执行计划
* mysql根据执行计划，调用存储引擎的API来进行查询并返回结果



## 算法题

### 25匹马，5个赛道，决出前5名至少需要比多少次

**决出前三名至少比7次；前五名至少8次，至多9次**

6次保底得到，字母表示赛道，下标表示名次

```c++
A1 B1 C1 D1 E1
A2 B2 C2 D2 E2
A3 B3 C3 D3 E3
A4 B4 C4 D4 E4
A5 B5 C5 D5 E5
```

用二叉树表示关系

<img src="https://img-blog.csdn.net/20180827175332871?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTE1ODUw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:70%;" />

**先讨论前三名的情况**

此时已决出第一名，根据路径往后搜索，即在(B1, C1, A2, B2, A3)中决出第二、三名

<img src="https://img-blog.csdn.net/20180827180241524?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTE1ODUw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:70%;" />

所以跑出前三名需要跑7次。

**前五名的情况**

在跑第七次的时候，可以得到第七次比赛的最后一名，此时有三种情况

> A3为最后一名
>
> C1为最后一名
>
> B2为最后一名

A3为最后一名时，A3后面的分支就不用看了，因为A3最高是第6名，比第6还慢的就不管了。此时树被剪枝成以下形状。此时前三名不管是(A1, A2, B1)还是其他，只需要按照树后各取分支两位(一共四位)决出前两名即可凑齐5名。以(A1, A2, B1)为例，取出的四位为(B2, C2, B1, C1)。一共比8次。

<img src="https://img-blog.csdn.net/2018082718294713?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTE1ODUw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:70%;" />



C1为最后一名时，此时第三名有三种情况A3, B2, (A2, B1)。

* 当第三名为A3时，前三名肯定时A1, A2, A3，此时挑选出树分支后面两位，即在编号(B1, B2, C2, B3, C3, A4, B4, A5)中取出第四名和第五名。取的策略跟前三名的策略一样，先在(B1, B2, B3, A4)中决出第四名，之后取第四名连接的后一位分支决出第五名。这里比2次+前面7次 = 9次（如果B1为第四名的话就8次）

  <img src="https://img-blog.csdn.net/20180827184919560?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTE1ODUw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:70%;" />

* 当第三名为B2时，前三名为A1, A2, B2，此时挑选出树分支后面两位，一共有6个点，还是需要比2次+前面7次 = 9次（如果B1为第四名的话就8次）

* 前三名为A1, A2, B1，选出树分支后面两位，一共有五个点，所以比8次

B2为最后一名的情况跟C1类似

### topk问题（力扣215）



# 深信服提问

### 结构体字节对齐

* 结构体中元素是按照定义顺序一个个放到内存中的，每个元素放置到内存中时，会认为内存是以它自己的大小来划分的，所以元素放置的位置一定在**自己宽度的整数倍上开始**

```c++
struct M {
    char c;//1-byte，再填充3byte，保证跟下列int对齐
    int i;//4-byte
    double d;//8byte
};//all：16-byte
```

* 检查完上诉原则后，检查计算出的存储单元是否为元素中最宽的元素长度的整数倍，若不是则补齐为它的整数倍

```c++
struct M{
    char c;//1-byte，再填充7-byte，保证跟下列double对齐
    double d;//8-byte
    int i;//4-byte，一共20-byte，不为double的整数倍，再填充8-byte
}//all：24byte
```

### Soket编程有了解吗

不会

### 从操作系统角度解释多线程为何高效

能并发？？？

### TCP三次握手丢包时是如何处理的

当Client端收到Server的SYN+ACK应答后，状态变为ESTABLISHED，并发送ACK包给Server；若此时ACK在网络中丢失，那么Server端该TCP连接的状态变为SYN_RECV，并且一次等待3s, 6s, 12s后重新发送，重发次数默认为5，如果超过重发次数后仍未收到ACK应答，那么一段时间后Server自动关闭该连接。但是Client认为这个连接已经建立，如果Client端向Server写数据，Server端将以RST包响应，才能感知到Server的错误。

## 算法题

### 过河问题，abcd四个人单独过河分别需要1，2，5，10min，问最少几分钟？

17min，1，2先过，1回来，5，10过，2回来，1，2过

2+1+10+2+2 = 17min

### 在长字符串中搜索字符集合中存在的元素，返回第一次出现的下标

标记字符集合中的元素，遍历长字符串，若某字符出现标记则break

### 有一个100层的大厦，丢两个鸡蛋的问题

**鸡蛋碎了比没碎更糟糕**

所以第一个蛋的尝试应该从低层开始，先有一个简单思路，把100分成10个10层，用第一个鸡蛋来确定在哪个10层里，再用第二个鸡蛋来确认具体层数

如果最高安全层数是16或96，那对于第一个鸡蛋，前者需要丢2次，后者10次，所以这样的区间划分对于丢的次数分布不均匀，对高层不利

**改进：**当第一个鸡蛋丢的次数越多时，减少第二个鸡蛋丢的次数，即区间划分应该呈递减

划分区间：

1， 2， 3， 4， ..., x	  区块1

x+1, x+2, ..., 					区块2

...

98, 99								区块n-1

100									区块n

已知总层数为100，从下往上看，前x项和要 >= 100，可求得x = 14，前14的和是105，多出了5，多的部分还能再各区间块内扣减，即区间分配变成

14， 13， 12， 11， 10， 9， 8， 7， 6， 5， 4， 3， 2， 1

对应答案是，第一次从第14层，没碎

到（14+13）=27层，没碎

到（27+12）=39层，没碎

到（39+11）=50层，没碎

到（50+10）=60层，没碎

到（60+9）=69层，没碎

到（69+8）=77层，没碎

到（77+7）=84层，没碎

到（84+6）=90层，没碎

到（90+5）=95层，没碎

到（95+4）=99层，没碎

去100层。

在各区间碎的情况下，最多实验次数分别为14，14，14，14，14，14，14，14，14，14，12，12

# 奇安信

### 一面：stl的增删改查，多态，继承，封装

### 程序运行时栈的具体作用，比如调用函数的时候，声明变量的时候

### 缓冲区溢出攻击

### 空类定义时会生成那些函数

缺省的构造函数，拷贝构造函数，析构函数，赋值运算符，两个取值运算符（const一个，没const一个）

没有算法题

### 二面直接挂：没项目，没啥可以问的，不会vs，最好去学学。。。（我用的clion）

# 迅雷

### 自旋锁和互斥锁的区别

自旋锁会使cpu处于忙等状态，互斥锁不会

### 简述三次握手和TCP如何实现可靠传输

### 文件的遍历方式

文件的结构树，即树的遍历

### dfs和bfs实现过程中所用到的数据结构

dfs为栈，bfs为队列

### 单核只能运行一个进程吗

采用时间切片的办法可以运行多个进程

### 什么是多态，怎么实现的

### 递归层数过多，爆栈怎么办

自己开栈（此时在内存中是堆结构），模拟递归

## 算法

### 1000瓶液体，不小心其中一瓶滴入剧毒，小白鼠喝毒后一晚就挂了，问至少要多少只小白鼠能在一晚内试出哪瓶有毒

10只小白鼠

1000转换成2进制，为10位，给10只小白鼠编号，液体编号的二进制上为1的位数，该位数的小白鼠就喂这瓶液体

有毒的那瓶就是挂了的小白鼠的编号组成的二进制

### 找第K大，递进：海量数据找第k大

topk，快排优化

递进：采用

