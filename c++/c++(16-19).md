# Primer c++第五版笔记6(到第19章完)

~~这是笔记，所以别问为什么写的跟书上一摸一样了~~

[TOC]

## 16 模板与泛型编程

### 16.1 定义模板

#### 16.1.1 函数模板

```cpp
template <typename T>
int compare(T a, T b) {
    if(a < b) return -1;
    if(b < a) return 1;
    return 0;
}

int main() {
    cout << compare(1, -1) << endl;
    return 0;
}
```

**非类型模板参数**

通过特定的类型名而非关键字 class 或 typename 来指定非类型参数

```cpp
// 处理字符串字面常量
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M]) {
    return strcmp(p1, p2);
}
int main() {
    cout << compare("hello", "world") << endl;
    return 0;
}
```

绑定到非类型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。不能使用动态对象作为指针或引用非类型模板参数的实参。

**inline和constexpr的函数模板**

```cpp
template<typename T> inline T min(const T&, const T&);
```

**编写类型无关的代码**

编写泛型代码的重要原则

* 模板中的函数参数是const 的引用
* 函数体中的条件判断仅使用< 比较运算

函数参数为const的引用能保证函数可以用于不能拷贝的类型

**模板编译**

当编译器遇到模板定义时，并不生成代码。只有实例化出模板的一个特定版本时，编译器才会生成代码。

函数模板和类模板成员函数的定义通常放在头文件中

#### 16.1.2 类模板

